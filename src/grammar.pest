char = _{
    // will consume ANY if the first char is not '"' or '\'
    !("\"" | "\\" ) ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

quote = { "\""}

chars = { char* }

// this will be atomic pair, and ~ means "immediately followed by".
// In addition, all other rules called from an atomic rule are also treated as atomic.
default = ${ quote ~ chars ~ quote }

range = { start? ~ ":" ~ end? }

index = { number? ~ ("," ~ number)* }

number = { ASCII_DIGIT+ }
start = { number }
end = { number }

array = _{ "[" ~ (range | index) ~ "]" }

selector = _{ array | object | default }

pipe = _{ "|" }

object_range = { range }
object_index = { index }
object_array = _{ "[" ~ (object_range | object_index) ~ "]" }
property = { (default | object_array)  ~ ("," ~ (default | object_array))* }

object = _{ "{" ~ property ~ "}" }

filter_default = { default }
filter_property = { (default | object_array) ~ ("," ~ (default | object_array)) * }
filter_object = _{ "{" ~ filter_property ~ "}" }
filter_range = { range }
filter_index = { index }
filter_array = _{ "[" ~ (filter_range | filter_index) ~ "]"}
filter_lens = _{ "=" ~ "{" ~ filter_lens_property ~ "}"}
filter_lens_key = { default }
filter_lens_value = { default}
filter_lens_key_value = { filter_lens_key ~ (":" ~ filter_lens_value)? }
filter_lens_property = { filter_lens_key_value ~ ("," ~ filter_lens_key_value)*}
filter = _{ filter_array | filter_object | filter_default | filter_lens }

filters = _ { pipe ~ filter ~ ("."? ~ filter)* }

spread = { ".." }

root = { "." }

truncate = { "!" }

selection = { (spread? ~ root? ~ (selector ~ ("."? ~ selector)*)?)? ~ filters* ~ truncate? }

groups = _{ selection ~ ("," ~ selection)* }

WHITESPACE = _{ " " }